## Idea

The main goal of this theses is to create a tool, which allows user to integrate a high-performance implementation of genetic algorithm for the arbitrary problem with minimum changes required to the existing codebase.
> The tool has to be flexible enough to be used with predefined concepts  

It has the core part of genetic algorithm implementation, which can be shared between different applications. It consist of a pipeline separated by three stages: selection, crossover and mutation, which evolves the population of individuls, increasing average level of adjustment and finding the best individual according to provided fitness function; preimplemented most popular strategies of genetic selection, crossover and mutation, with possibility of providing additional ones for specific reasons and a set of platforms which allow to run the pipeline in a different ways, best suited for existing hardware.


### Key concepts
[comment]: # (ToDo - add description)
In order to create a solution which will resolve existing problems of usage of genetic algorithms in business and academia applications

#### Arbitrary representation of individual
There is a wide set of problems which might be resolved using genetic algorithms. Still this optimization technique is rarely used in business applications and mainly considered as theoretical solution. One of the reasons of such phenomenon is the difficulty which comes with a try to use genetic algorithm optimization without previous plan to do so. The process of reshaping the existing codebase in a such way, so typical genetic algorithm could be applying often demands big costs and high level of understanding GA workflow and its possibilities. 

Depending on the problem a user is trying solve, a standard representation of each candidate solution would be an array of bits, integers or real numbers. The main property that makes these genetic representations convenient is that their parts are easily aligned due to their fixed size, which facilitates simple crossover operations. For the purposes of genetic programming and evolutionary programming tree-like and graph-form representation are used respectively, which couses the necessity in different implementations for each problem.

A solution for this problem is implementation of genetic algorithm, which is able to work on generic types, which represents a candidate solution for applied problem. Due to this property it is possible to reuse the implementation for different problems and create a generic tool, which is decoupled from the problem it is applied to.

#### Local and distributed parallelization
Genetic algorithms are generally known as a time-consuming technique, as it is often used with complex, high-dimensional problems. Evolution cycle may take up to hours and days of continuous computing, depending on the parameters of the algorithm and a hardware in use, which comes with a great costs and very low flexibility, as with every mistake or change done to algorithm implementation, evolution needs to be reexecuted. On the other hand, even small upgrades in speed may result as a major cost cut.

For this reason it is highly important to use the maximum of the given resources, avoiding unreasonable workloads. It may be achieved through the computation parallelization between multiple virtual CPU cores within a single machine and distributing computation in a cluster of working nodes. For the better result, two approaches may be combined and used together.

[comment]: # (May be expanded)

#### Large size of the population
The important parameter of genetic algorithm is population size. It controlls how many individuals are going to be processed by algorithm during one evolution step. When applying to a problem with a wide range of possible solutions the *algorithm tends to find optimal solution faster, while operating on the large number of candidates at once*. It makes  every population more diverse, which leads to faster identification of better candidate and also allows to cover more subsets of function arguments at the beginning of evolution process.

A typical limitation of the number of objects one can use at a time is the capacity of RAM space. Working with large sets of data, while keeping them in memory like collections in Java or many other programming languages, may leed to exceeding the capabilities of the hardware, resulting in a crash of application or undefined behavior. In order not to limit the users, in their options it must be possible to store the parts or whole population on disk (which usually is more spacious than RAM), while processing the population in parts, which may be safely stored in faster RAM. The choice of the way, how the algorithm will store its intermediate data should be open to the end users, enabling them to make a decision upon their own preferences, which may be connected to the existing software and hardware. These parameters will be different among different applications the tool is used for, so it needs to provide both options, as well as their combination, out of the box.

>This propery was not met in existing solutions, due to possible issues, among which is RAM limitation and long time of processing. However, with abillity to efficiently reuse objects

#### On-demand evolution
Genetic algorithm optimization is generally used for finding the best solution for a defined problem, which is the most fit candidate to provided fitness function. It means, that the best solution is defined relatively to all the solutions assigned earlier and cannot be proved as the optimal one, even when it is. But when applying to a nontrivial problems, finding the optimal solution is not always cost-effective, as it may take up to exponensial time. For this reason, it is common to compute a 'good enough' solution in reasonable time. Depending on the buisiness reasons, this time vary so sometimes it is possible to wait until the better solution is computed and sometimes it is not. For instance, if the application which uses genetic algorithm has a real time interface and its user is interested in gaining a solution for partical case in the range of seconds, it is justifiable to provide a solution which may not be the optimal, but is close to it. 

On the other hand, when a user is ready to allow application to take its time in order to provide a better result, it has to still be possible to resume the evolution. Again the application should not limit users in such important cases, as the end user needs may vary depending on different circumstances, which may not be predicted in advance. The evolution of solution to a given problem should be available on-demand, without forcing unreasonable resource uses, and adjust to a specific case as much as possible.

[comment]: # (May be edited [last chapter])

#### Flexible evolution flow
Being able to combine different flows and to start from any population, which may be result of the previous evolution.