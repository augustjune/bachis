\chapter{Introduction}

\section{Domain overview}

Starting from the definition, an evolutionary algorithm (EA) is a subset of evolutionary computation, a generic population-based metaheuristic optimization algorithm. An EA uses mechanisms inspired by biological evolution, such as reproduction, mutation, recombination, and selection. Candidate solutions to the optimization problem play the role of individuals in a population, and the fitness function determines the quality of the solutions. Evolution of the population then takes place after the repeated application of the above operators.

The idea of searching among a collection of candidate solutions for a desired solution is so common in computer science that it has been given its own name: searching in a "search space." Here the term "search space" refers to some collection of candidate solutions to a problem and some notion of "distance" between candidate solutions. \cite{introduction_to_ga}

Evolutionary algorithms often perform well-approximating solutions to all types of problems because they ideally do not make any assumption about the underlying fitness landscape. Techniques from evolutionary algorithms applied to the modeling of biological evolution are generally limited to explorations of microevolution processes and planning models based upon cellular processes. In most real applications of EAs, computational complexity is a prohibiting factor. However, seemingly simple EA can solve often complex problems; therefore, there may be no direct link between algorithm complexity and problem complexity.

Overall the optimization methods can be divided into two groups: the gradient methods, that operate on a single potential solution and look for some improvements in its neighborhood, and global optimization techniques – represented here by so-called evolutionary methods – that maintain large sets (populations) of potential solutions and apply some recombination and selection operators on them. During the last decades, evolutionary methods have received a considerable attraction and have experienced rapid development. Main paradigms are: genetic algorithm (binary or real coded), augmented simulated annealing (binary or real coded), evolution strategy and differential evolution. Still, each of these methods has many possible improvements.

In this thesis, the author is concentrating on a subfamily of evolution methods named genetic algorithms. Genetic algorithms are a subset of Evolutionary algorithms inspired by Charles Darwin's work on evolution by natural selection. They are metaheuristic search algorithms relying on bio-inspired operators such as mutation, crossover, and selection. Genetic algorithms, in particular, became popular through the work of John Holland in the early 1970s.

In contrast with evolution strategies and evolutionary programming, Holland's original goal was not to design algorithms to solve specific problems, but rather to formally study the phenomenon of adaptation as it occurs in nature and to develop ways in which the mechanisms of natural adaptation might be imported into computer systems. Holland's 1975 book Adaptation in Natural and Artificial Systems presented the genetic algorithm as an abstraction of biological evolution and gave a theoretical framework for adaptation under the GA. Holland's GA is a method for moving from one population of "chromosomes" (e.g., strings of ones and zeros, or "bits") to a new population by using a kind of "natural selection" together with the genetics-inspired operators of crossover, mutation, and inversion. Each chromosome consists of "genes" (e.g., bits), each gene being an instance of a particular "allele" (e.g., 0 or 1). The selection operator chooses those chromosomes in the population that will be allowed to reproduce, and on average the fitter chromosomes produce more offspring than the less fit ones. Crossover exchanges subparts of two chromosomes, roughly mimicking biological recombination between two single-chromosome ("haploid") organisms; mutation randomly changes the allele values of some locations in the chromosome; and inversion reverses the order of a contiguous section of the chromosome, thus rearranging the order in which genes are arrayed. \cite{introduction_to_ga} 

\subsection{How evolutionary algorithms are used nowadays?}
 
To evolutionary-computation researchers, the mechanisms of evolution seem well suited for some of the most pressing computational problems in many fields. Many computational problems require searching through a huge number of possibilities for solutions. One example is the problem of computational protein engineering, in which an algorithm is sought that will search among the vast number of possible amino acid sequences for a protein with specified properties. Another example is searching for a set of rules or equations that will predict the ups and downs of a financial market, such as that for foreign currency. Such search problems can often benefit from an effective use of parallelism, in which many different possibilities are explored simultaneously in an efficient way. \cite{introduction_to_ga}

Typically, optimization methods arising in engineering design problems are computationally demanding because they require the evaluation of a quite complicated objective function many times for different potential solutions. Moreover, the objective function is often multi-modal, non-smooth or even discontinuous, which means that traditional, gradient-based optimization algorithms fail and global optimization techniques, which generally need even a larger number of function calls, must be employed. Fortunately, the rapid development of computational technologies and hardware components allows us to treat these problems within a reasonable time.

Genetic algorithms have been applied in science, engineering, business, and social sciences. A number of scientists have already solved many engineering problems using genetic algorithms. It is widely used in designing composite materials and aerodynamic shapes for race cars and regular means of transportations (including aviation). Getting the most out of a range of materials to optimize the structural and operational design of buildings, factories, machines, etc. is a rapidly expanding application of GAs. These are being created for such uses as optimizing the design of heat exchangers, robot gripping arms, satellite booms, building trusses, flywheels, turbines, and just about any other computer-assisted engineering design application. 

Another growing field of genetic algorithms applications is robotics. Robotics involves human designers and engineers trying out all sorts of things in order to create useful machines that can do work for humans. Each robot’s design is dependent on the job or jobs it is intended to do, so there are many different designs out there. GAs can be programmed to search for a range of optimal designs and components for each specific use, or to return results for entirely new types of robots that can perform multiple tasks and have more general application.

There are still many other domains left from chemical kinetic analysis to marketing and merchandising, where genetic algorithms are capable of producing a better result in a lot faster time segment comparing to people.

\subsection{Disadvantages}
As every other technique, genetic algorithm has its flaws. In this thesis, the author tries to attract attention to the two most important disadvantage of genetic algorithms, due to subjective opinion. For each of them is proposed an alternative solution, which will later take place in the functional requirements of the thesis work.

\begin{enumerate}
\item \textbf{Implementation complexity}

There are many problems of different types, which may be optimized by genetic algorithms. The downside is that for each of those problems there is a need for specific implementation, which is at least time-consuming. Even though the low-level details, which depend on the problem GA is applied to, will change, the high-level abstraction of genetic algorithm workflow remains the same. This makes it possible to implement a generic representation of a genetic algorithm, which may be reusable among a variety of application and be independent of the low-level details. 
\medbreak

\item \textbf{Computation cost}

Genetic algorithms tend to be very time-consuming. This is strictly related to its computation model, as the function, used in GA, are usually very demanding. There are a lot of approaches to decrease the time it takes to produce a desirable result by applying cached (or partly cached) fitness function or use its approximation, avoiding the large-size data and using many low-level optimizations in different parts of the algorithm. All of these improvements are beneficial but take time to implement.

An additional method for performance optimization, available right out of the box is workflow parallelization. This should allow users to use full capabilities of hardware in their use and also be transparent for users, saving them a lot of efforts and time.
\medbreak

\end{enumerate}

\section{Solution criteria}

A solution for described flaws would be a tool, which allows to integrate a high-performance implementation of the genetic algorithm into user application and use it for the arbitrary optimization problem with minimum changes required to the existing codebase. Additionally, this should be a convenient toolbox for theoretical and practical problems which might be resolved using genetic algorithms, providing a ready-made implementation of the most popular algorithms with extra features, which save users from implementing one themselves. For a solution to be considered as fulfilled, it is necessary to meet both functional and non-functional requirements predefined in advance.

\subsection{Non-functional requirements}
\begin{enumerate}
\item \textbf{Java Virtual Machine}

This platform was chosen, because of its popularity and open nature. Java virtual machine is supported by many languages, what allows a user to pick a specific one, which is the best for given circumstances. JVM is also vastly used and run on over 3 billion devices\footnote{According to official information provided by Oracle Corporation.}. It takes the responsibility of platform organizing hardware environment, allowing the application designers to be platform agnostic. It is very convenient in terms of program correctness - meaning that if the program runs on one machine, it is highly probable to run as expected on the other machine satisfying minimum requirements. Sun's famous slogan \textit{``Write once, run everywhere''} is only valid due to Java virtual machine and its ability to run standard bytecode.
\medbreak

\item \textbf{Open implementation}

The implementation of the tool has to be open to its users, allowing to view and expand source code to the specific needs. 
\medbreak

\item \label{nfreq:modul}\textbf{Modular architecture}

The architecture solution used to build the tool must contain modularity among its fundamentals. This means, that allowing different features, its components have to be grouped according to their functions, so users, who are interested in a small part of provided functionality wouldn't be forced to use all capabilities of the tool.

\end{enumerate}

\subsection{Functional requirements}
\begin{enumerate}
\item \label{freq:stop} \textbf{Limiting the evolution in terms of time and/or number of iterations}

This is the basic requirement for every genetic algorithm implementation. Evolution process takes time and in order to benefit from it, a user must have access to the evolved version of the population. A number of iterations corresponding to the number of evolution cycles performed on the population, when every genetic operator is applied to it. On the other hand, the actual time of the evolution may be changed even in terms of the same number of iterations, as it strongly depends on the performance of genetic operators and fitness function, so in some cases, time may be the only valid criterion, which decides that evolution process should be stopped. 
\medbreak

\item \label{freq:best} \textbf{Control of the best individual through evolution}

During the evolution process, due to the chosen selection, crossover or mutation strategies, even the fittest individual may not end in the next population. As for business needs, it is important to get the best solution ever discovered by the algorithm, it is useful to store the reference to that candidate separately, as well as its fitness value to avoid unnecessary re-computation.
\medbreak

\item \label{freq:cache} \textbf{Fitness values caching}

In genetic algorithms, the computation of the fitness function comes with the largest computational load for the algorithm. Each population generation is composed of individuals who are formed from the previous generation via cloning, crossover, or mutation. For each new individual it necessary to assign a fitness function value, which determines how good a candidate is. It is also common for the individual to migrate to the next population without a change or, less common, a crossover of two different individuals may produce a genotype that already has been discovered earlier. If this occurs frequently, it is unprofitable to compute the fitness value all over again. As a solution, one may consider caching the results of fitness computation for later re-usage. Although it noticeably increases the speed of the algorithm, the cache tends to grow very fast, so the choice of data structure for this purposes is extremely important. 
\medbreak

\item \label{freq:par} \textbf{Parallel evolution processing}

Genetic algorithms are generally known as a time-consuming technique, as it is often used with complex, high-dimensional problems. Evolution cycle may take up to hours and days of continuous computing, depending on the parameters of the algorithm and hardware in use, which comes with a great cost and very low flexibility, as with every mistake or change was done to algorithm implementation, evolution needs to be re-executed from scratch. On the other hand, even small upgrades in speed may result as a major cost cut.

For this reason, it is highly important to use the maximum of the given resources, avoiding unreasonable workloads. It may be achieved through the computation parallelization between multiple virtual CPU cores within a single machine.
\medbreak

\item \label{freq:async} \textbf{Asynchronous evaluation of fitness value}

The solution must allow to compute fitness values on a different machine or even cluster of machines, as well as using a different low-level programming language or some specific optimization, with no need to switch the entire application to another platform. This feature will make a great impact in the case of cloud computing solutions, as fitness evaluation may be entirely isolated from the rest of application.
\medbreak

\item \label{freq:generic} \textbf{Generic representation of individual}

There is a wide set of problems which might be resolved using genetic algorithms. Still, this optimization technique is rarely used in business applications and mainly considered as a theoretical solution. One of the reasons for such phenomenon is the difficulty which comes with a try to use genetic algorithm optimization without a previous plan to do so. The process of reshaping the existing codebase in such way, so typical genetic algorithm could be applying often demands big costs and high level of understanding GA workflow and its possibilities.

Depending on the problem a user is trying to solve, a standard representation of each candidate solution would be an array of bits, integers or real numbers. The main property that makes these genetic representations convenient is that their parts are easily aligned due to their fixed size, which facilitates simple crossover operations. For the purposes of genetic programming and evolutionary programming tree-like and graph-form representation are used respectively, which causes the necessity in different implementations for each problem.

A solution to this problem is an implementation of the genetic algorithm, which is able to work on generic types, which represents a candidate solution for the applied problem. Due to this property, it is possible to reuse the implementation for different problems and create a generic tool, which is decoupled from the problem it is applied to.
\medbreak

\item \label{freq:distributed} \textbf{Evolution in distributed environment}

As already mentioned, parallelization is a big part of speed optimization for genetic algorithms. While local parallelization is useful and convenient for medium- and small-sized problems, working with complex use cases often demands the resources, which may not fit into one machine. Distributed environment is the next step of parallelization when evolution process is split between different machines, each computing its own part of the workload. This approach enables horizontal scaling when each added machine increases the performance of the algorithm.
\medbreak

\item \label{freq:on-demand} \textbf{On-demand evolution}

Genetic algorithm optimization is generally used for finding the best solution for a defined problem, which is the fittest candidate to the provided fitness function. It means, that the best solution is defined relative to all the solutions assigned earlier and cannot be proved as the optimal one, even when it is. But when applying to a nontrivial problem, finding the optimal solution is not always cost-effective, as it may take up to exponential time. For this reason, it is common to compute a 'good enough' solution in reasonable time. Depending on the business reasons, this time varies so sometimes it is possible to wait until the better solution is computed and sometimes it is not. For instance, if the application which uses genetic algorithm has a real-time interface and its user is interested in gaining a solution for the particular case in the range of seconds, it is justifiable to provide a solution which may not be optimal but is close to it.

On the other hand, when a user is ready to allow the application to take its time in order to provide a better result, it has to still be possible to resume the evolution. Again the application should not limit users in such important cases, as the end user needs may vary depending on different circumstances, which may not be predicted in advance. The evolution of a solution to a given problem should be available on-demand, without forcing unreasonable resource uses, and adjust to a specific case as much as possible.
\medbreak
\end{enumerate}